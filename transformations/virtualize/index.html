<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<style type="text/css">

html {
   margin: 0;
   padding: 0;
}

a.anchor{
   display: block; 
   position: relative; 
   top: -120px; 
   visibility: hidden;
}

.alert {
    border: 1px solid black;
    margin-left: 5%;
    margin-right: 5%;
    padding: 5px 20px;
    background-color:#FFE29E;
}

.alert p {
   width: 90%;
}

hr {
  background: #9E329E;
  old-background: #f17836; 
  clear: both; 
  float: none; 
  width: 100%; 
  height: 4px;
  margin: 0 0 1.4em;
  border: none; 
}

.no-bullets li {
   list-style-type: none;
}

ul.no-bullets {
   padding: 0; 
   margin: 0;
   margin-top: 130px;
   margin-left: 1em;
   padding-left: 0;
}

.deftable tr {
   vertical-align: top;
   border-bottom: 1px solid black;
   border-spacing:0 5px;
}
table.deftable {
   width: 800px;
   table-layout: fixed;
   border-collapse:collapse;
}
.deftable td {
    overflow: hidden;
    width: 266px;
}
.deftable tr:last-child {
    border-bottom: 0;
}
.deftable th {
    overflow: hidden;
    width: 266px;
    border-bottom: 2px solid black;
}

.downloadtable tr {
   vertical-align: top;
   border-bottom: 1px solid black;
   border-spacing:0 5px;
}
table.downloadtable {
   width: 800px;
   table-layout: fixed;
   border-collapse:collapse;
}
.downloadtable td {
    overflow: hidden;
    width: 150px;
}
.downloadtable tr:last-child {
    border-bottom: 0;
}
.downloadtable th {
    overflow: hidden;
    width: 150px;
    border-bottom: 2px solid black;
}

.exampletable tr {
   vertical-align: top;
   border-bottom: 1px solid black;
}
table.exampletable {
   width: 800px;
   table-layout: fixed;
   border-collapse:collapse;
   margin-bottom: 2em;
}
.exampletable td {
    overflow: hidden;
    width: 800px;
}
.exampletable tr:last-child {
   border-bottom: 2px solid black;
}
.exampletable th {
    overflow: hidden;
    width: 800px;
    border-bottom: 2px solid black;
}

.virttable tr{
   vertical-align: top;
   border-bottom: 1px solid black;
}
table.virttable {
   width: 800px;
   table-layout: fixed;
   border-collapse:collapse;
   margin-bottom: 2em;
}
td.virttable {
    overflow: hidden;
    width: 800px;
}
th.virttable {
    width: 800px;
    border-bottom: 1px solid black;
}

p {
   width: 780px;
}

ul p {
   width: 500px;
}

ol p {
   width: 500px;
}

table.smalltab {
   width: 500px
   table-layout: fixed;
   border-collapse:collapse;
   border-spacing:0 5px;
   margin-left:auto; 
   margin-right:auto;
}
.smalltab tr {
   vertical-align: top;
   border-bottom: 1px solid black;
}
.smalltab td {
    overflow: hidden;
    width: 250px;
}
.smalltab tr:last-child {
  border-bottom: none;
}
.smalltab th {
    overflow: hidden;
    width: 250px;
    border-bottom: 2px solid black;
}

#header {
  background: #9E329E;
  old-background: #f17836; 
   margin-left: 200px;
   min-width: 800px;
   max-width: 800px;
   padding: 15px 0 15px 15px;
   position: fixed;
   top:0;
   left:0;
   margin-top:-28px;
   background-image:url(img/tigress-white.png);
   background-repeat: no-repeat; 
   background-position: right;
   background-size:40%;
}

h3 {
  margin-top: 0;
  margin-bottom: 0;
}

#content {
   padding: 0;
   margin: 0;
   margin-left: 0;
}

#main-content {
   margin-left: 200px;
   min-width: 800px;
   max-width: 800px;
   overflow-y: auto;
   overflow-x: hidden;
   left: 0;
   padding-top: 100px;
}

#sidebar {
   margin-left: 0;
   width: 200px;
   position: fixed;
   top: 0;
   bottom: 0;
   left: 0;
   padding: 0;
   margin: 0;
   height: 100%;
   overflow: auto;
   old-background: #f5a67a;
   background: #B246B2;
}

#sidebar ul {
   list-style: inside;
}

code, samp, kbd {
	font-family: "Courier New", Courier, monospace, sans-serif;
	text-align: left;
	color: #555;
	}
pre code {
	line-height: 1.6em;
	font-size: 11px;
	}
pre {
	padding: 0.1em 0.5em 0.3em 0.7em;
	border-left: 1px solid #ccc;
	margin: 1.7em 0 1.7em 0.3em;
	overflow: auto;
	width: 93%;
	}
/* target IE7 and IE6 */
*:first-child+html pre {
	padding-bottom: 2em;
	overflow-y: hidden;
	overflow: visible;
	overflow-x: auto; 
	}
* html pre { 
	padding-bottom: 2em;
	overflow: visible;
	overflow-x: auto;
	}
</style>
</head>
<body>

<div id="header">
   <h1>Function Virtualization</h1>
</div>
<div id="content">
   <div id="sidebar">
      <ul class="no-bullets">
         <li><a href="../../../index.html">Tigress Home</a>
         <li><a href="../../../transformPage/index.html">Transformations</a>
         <li> &nbsp;
         <li><a href="#diversity">Diversity and Stealth</a>
         <li><a href="#dispatch">Dispatch</a>
         <li><a href="#ISA">ISA Generation</a>
         <li><a href="#ISADiversity">Superoperators</a>
         <li><a href="#HandlerObfuscation">Obfuscation</a>
         <li><a href="#VPCObfuscation">VPC obfuscation</a>
         <li><a href="#BogusFunctions">Bogus Functions</a>
         <li><a href="#BogusLoops">Bogus Loops</a>
         <li><a href="#Reentrant">Reentrant Interpreters</a>
         <li><a href="#EncodingProgram">Encoding Programs</a>
         <li><a href="#DynamicProgram">Dynamic Programs</a>
         <li><a href="#options">Options</a>
         <li><a href="#examples">Examples</a>
         <li><a href="#issues">Issues</a>
      </ul>
   </div>
   <div id="main-content">
<!-- =============================================================================================== -->

<a class="anchor" id="virtualize">&nbsp;</a>
<p>
   This transformation turns a function into an interpreter, whose
   bytecode language is specialized for this function. The
   transformation has been designed to induce as much diversity as
   possible, i.e. every decision made is dependent on the
   randomization seed. The diversity is both static and dynamic, i.e. each
   interpreter variant differs in the structure of its code as well as
   in its execution pattern.
</p>

<center><img width="500px" src="tigress-virtualize.png"></center>

<p>
A generated interpreter consists of a virtual instruction set, 
specialized for the input function, a bytecode array, a virtual
program counter (VPC), a virtual stack pointer (VSP), a dispatch
unit, and a list of instruction handlers, one for each virtual
instruction:
<center><img width="500px" src="interpret-3.png"></center>
</p>

<p>
For this transformation, Tigress first constructs type-annotated
abstract syntax tree (AST) from the C source, from which it generates
control-flow graphs of instruction trees. Tigress then selects a random
instruction set architecture (ISA) and, using this ISA, generates a
bytecode program specialized for the input function. Finally, Tigress
selects a random dispatch method and produces an output program.
</p>

<a class="anchor" id="diversity">&nbsp;</a>
<h3>Diversity and Stealth</h3>
<p><b>Static diversity.</b> Tigress supports two mechanisms for generating 
ISAs with a high degree of static diversity:</p> 
<ul>
   <li> instruction opcodes can be randomized,
   <li> the ISA can have duplicate instructions with the same semantics, 
   <li> instructions can pass arguments in arbitrary combinations of stack locations and registers, 
   <li> instructions can be made arbitrarily long (with highly complex semantics) through the use of superoperators. 
</ul>

<p><b>Dynamic diversity.</b> We ensure that dynamic execution patterns are 
diversified by merging randomized bogus functions with the ``real'' 
function. We can furthermore impede dynamic analysis by making instruction
traces artificially long.
</p>

<p>
<b>Static stealth.</b>
Not only diversity but also <em>stealth</em> is important for
interpreters. For static stealth, the <tt>split</tt> transformation can break up the
interpreter loop into smaller pieces, and the <tt>AddOpaque</tt>
transformation can make instruction handlers less conspicuous.
</p>

<p>
<b>Dynamic stealth.</b>  For dynamic stealth, Tigress interpreters can
be made <em>reentrant</em>, meaning only a few iterations of the
dispatch loop are executed at a time, effectively mixing instructions
executed from the interpreter with instructions executed by the rest
of the program. This is of particular interest when wanting to hide
the execution pattern from analysts, and when the exact time that the
function executes is not important, as long as it completes <em>eventually</em>.
</p>

<a class="anchor" id="dispatch">&nbsp;</a>
<h3>Dispatch Method Selection</h3>
<p>For both static and dynamic diversity, Tigress supports eight different
dispatch methods. The following code is generated for the different methods,
   where &Xi;<sup><tt>op1</tt></sup>; is the instruction handler for
   operator <tt>op1</tt>:</p>

<table class="smalltab">
   <tr><th>Dispatch</th><th>Generated code</th></tr>

   <tr>
   <td>switch</td>
   <td>
<pre>
switch(prog[pc]) {
   op1: &Xi;<sup><tt>op1</tt></sup>; break;
   op2: &Xi;<sup><tt>op2</tt></sup>; break;
}
</pre>
   </td>
   </tr>

   <tr>
   <td>direct</td>
   <td>
<pre>
goto *prog[pc];
op1hdl: &Xi;<sup><tt>op1</tt></sup>; goto *prog[pc];
op2hdl: &Xi;<sup><tt>op2</tt></sup>; goto *prog[pc];
</pre>
   </td>
   </tr>

   <tr>
   <td>indirect</td>
   <td>
<pre>
goto *jtab[prog[pc]];
op1hdl: &Xi;<sup><tt>op1</tt></sup>; goto *jtab[prog[pc]];
op2hdl: &Xi;<sup><tt>op2</tt></sup>; goto *jtab[prog[pc]];
</pre>
   </td>
   </tr>

   <tr>
   <td>call</td>
   <td>
<pre>
void op1fun(){&Xi;<sup><tt>op1</tt></sup>}
void op2fun(){&Xi;<sup><tt>op2</tt></sup>}
&hellip;
call *prog[pc]();
</pre>
   </td>

   <tr>
   <td>ifnest</td>
   <td>
<pre>
if (prog[pc]==op1) &Xi;<sup><tt>op1</tt></sup>
else if (prog[pc]==op2) &Xi;<sup><tt>op2</tt></sup>
else if &hellip;
</pre>
   </td>

   <tr>
   <td>linear, binary, interpolation</td>
   <td>
<pre>
alg = linear|binary|interpolation|&hellip;
top: 
   goto *(<bf>search</bf><sup>alg</sup>(map,prog[pc]));
op1hdl: &Xi;<sup><tt>op1</tt></sup>; goto top;
op2hdl: &Xi;<sup><tt>op2</tt></sup>; goto top;
</pre>
   </td>
   </tr>
</table>

<!-- -------------------------------------------------------------------------------- -->

<a class="anchor" id="ISA">&nbsp;</a>
<h3>Instruction Set Architecture Generation</h3>
<p>Instruction sets can use stacks, registers, or both to pass values
between instructions. By default, the following, very simple, instruction
set is used:</p>
<pre>
  labels:         l &isin; <it>Labels</tt> 
  functions:      f &isin; <it>Funs</it> 
  variables:      x &isin; <it>Vars</it> 
  strings:        s &isin; <it>Strings</it> 
  temporaries:     t ::= <tt>reg</tt><sup><it>int</it></sup> | <tt>stack</tt><sup><it>int</it></supt>  
  binary operators: <it>binop</it> ::= <tt>add</tt> | <tt>sub</tt> | &hellip;
  unary operators:  <it>unop</it> ::= <tt>uminus</tt> | <tt>neg</tt> | &hellip;
  types:           &tau; ::= <tt>int</tt> | <tt>float</tt> | &hellip; | <tt>void *</tt>
  literals:        &lambda; ::= <tt>intlit</tt> | <tt>floatlit</tt> | &hellip;
  instructions: e ::=  
       t &larr; <tt>constant</tt> &tau; &lambda;
     | t &larr; <tt>local</tt>  x
     | t &larr; <tt>global</tt>  x
     | t &larr; <tt>formal</tt>  x
     | t &larr; <tt>string</tt>  s
     | t &larr; <tt>binary</tt>  &tau;  <it>binop</it> t t
     | t &larr; <tt>unary</tt>  &tau;  <it>unop</it> t
     | t &larr; <tt>convert</tt>  &tau; &tau; t
     | t &larr; <tt>ternary</tt>  &tau; t t t
     | t &larr; <tt>load</tt>  &tau; t
     | <tt>store</tt> &tau; t t
     | t &larr; <tt>memcpy</tt>  t t <it>int</it>
     | <tt>call</tt>  f
     | x, x, &larr; <tt>asm</tt>  s  t, t, &hellip;
     | <tt>indirectCall</tt>  t
     | <tt>return</tt>  &tau; t
     | <tt>goto</tt>  l
     | t &larr; <tt>addrOfLabel</tt>  l
     | <tt>indirectGoto</tt>  t
     | <tt>branchIfTrue</tt>  t  l 
     | <tt>switch</tt>  &tau; t  &lambda;  &lambda;  l &lang;l, l, &hellip;&rang; 
     | <tt>merged</tt>  &lang; e, e, \ldots&rang; 
</pre>

<p>However, a high degree of diversity can be achieved from the way
instructions communicate with each other, through values stored on the
stack or passed in virtual registers.  Tigress can generate
instructions that use any combination of registers and stack storage
for the inputs they read or the output they produce.
</p>

<a class="anchor" id="ISADiversity">&nbsp;</a>
<h3>ISA Diversity through Duplicate Operators and Superoperators</h3>
<p>
Tigress can induce further diversity by merging
instructions into <em>superoperators</em>. New, merged, instructions
can have an almost abritrary complex semantics, involving multiple arithmetic 
operations and operations both on the stack and virtual registers.
For more information on superoperators, see
<a href="http://dl.acm.org/citation.cfm?id=199526">Optimizing an ANSI
C interpreter with superoperators</a>
by <a href="http://proebsting.cs.arizona.edu">Todd Proebsting</a>.
The complex semantics of instructions generated by superoperators make
manual analysis of generated interpreters, such as discussed by Rolles
in <a href="http://dl.acm.org/citation.cfm?id=1855877">Unpacking
virtualization obfuscators</a>, difficult.
</p>

<p>Consider setting <tt>--VirtualizeMaxDuplicateOps=2</tt> 
and <tt>--VirtualizeOperands=mixed</tt> resulting in two <em>store-int</em>
instructions, one that takes both arguments in registers, and one that takes
one argument on the stack and the other in a register. Tigress will chose 
between them randomly. Here are the corresponding instruction handlers:</p>
<pre>
case _0__store_int$left_REG_0$right_REG_1: 
   (_0__pc[0]) ++;
   *((int *)_0__regs[0][*((int *)_0__pc[0])]._void_star) = _0__regs[0][*((int *)(_0__pc[0] + 4))]._int;
   _0__pc[0] += 8;
   break;

case _0__store_int$right_STA_0$left_REG_0: 
   (_0__pc[0]) ++;
   *((int *)_0__regs[0][*((int *)_0__pc[0])]._void_star) = _0__stack[0][_0__sp[0] + 0]._int;
   (_0__sp[0]) --;
   _0__pc[0] += 4;
   break;
</pre>

<p>Consider next setting <tt>--VirtualizeSuperOpsRatio=2.0</tt> and <tt>--VirtualizeMaxMergeLength=10</tt>,
resulting in virtual instructions with highly complex semantics:

<center><img width="500px" src="super-operators-3.png"></center>

Here is the instruction handler for one such instruction, made up by merging 10 primitive instructions:</p>
<pre>
case _0__local$result_STA_0$value_LIT_0__\
   convert_void_star2void_star$left_STA_0$result_REG_0__\
   load_int$result_REG_0$left_REG_1__\
   local$result_STA_0$value_LIT_0__\
   convert_void_star2void_star$left_STA_0$result_REG_0__\
   store_int$left_REG_0$right_REG_1__\
   local$result_REG_0$value_LIT_1__\
   local$result_STA_0$value_LIT_0__\
   convert_void_star2void_star$left_STA_0$result_REG_0__\
   load_int$result_STA_0$left_REG_0: 
    (_0__pc[0]) ++;
    _0__regs[0][*((int *)(_0__pc[0] + 4))]._void_star = (void *)(_0__locals + *((int *)_0__pc[0]));
    _0__regs[0][*((int *)(_0__pc[0] + 8))]._int = *((int *)_0__regs[0][*((int *)(_0__pc[0] + 12))]._void_star);
    _0__regs[0][*((int *)(_0__pc[0] + 20))]._void_star = (void *)(_0__locals + *((int *)(_0__pc[0] + 16)));
    *((int *)_0__regs[0][*((int *)(_0__pc[0] + 24))]._void_star) = _0__regs[0][*((int *)(_0__pc[0] + 28))]._int;
    _0__regs[0][*((int *)(_0__pc[0] + 32))]._void_star = (void *)(_0__locals + *((int *)(_0__pc[0] + 36)));
    _0__regs[0][*((int *)(_0__pc[0] + 44))]._void_star = (void *)(_0__locals + *((int *)(_0__pc[0] + 40)));
    _0__stack[0][_0__sp[0] + 1]._int = *((int *)_0__regs[0][*((int *)(_0__pc[0] + 48))]._void_star);
    (_0__sp[0]) ++;
    _0__pc[0] += 52;
    break;
</pre>
<p>Note that the instruction name really is almost 400 characters long; the
backslashes are here only for display purposes! Also note that the instruction
itself is 53 bytes long, almost as long as the 
<a href="https://groups.google.com/forum/#!topic/comp.arch/OJYBg8o7vcQ">longest VAX instruction</a>
(<tt>EMODH</tt>, 54 bytes) and much longer than the longest x86 instruction 
(15 bytes) </p>

<!-- -------------------------------------------------------------------------------- -->

<a class="anchor" id="HandlerObfuscation">&nbsp;</a>
<h3>Instruction Handler Obfuscation</h3>
<p>You can split up the generated interpreter by inserting opaque predicates. This is useful to 
make the instruction handlers and the dispatch logic less conspicuous.</p>

<center><img width="500px" src="split-instruction-handlers-2.png"></center>

<!-- -------------------------------------------------------------------------------- -->

<a class="anchor" id="VPCObfuscation">&nbsp;</a>
<h3>VPC Obfuscation</h3>
<p>You can add opaque expressions to the virtual PC to make it 
more difficult to find.</p>

<p>One possible attack on interpreters is to perform a taint analysis
on input-dependent variables, and discard any instructions which are
not tainted (input dependent instructions are colored green, 
and instructions introduced by the virtualizer are colored blue):
<center><img width="500px" src="implicit-flow-4.png"></center>
To frustrate such analyses we can add implicit flow to the VPC:
<center><img width="500px" src="implicit-flow-6.png"></center>

</p>

<!-- -------------------------------------------------------------------------------- -->

<a class="anchor" id="BogusFunctions">&nbsp;</a>
<h3>Bogus Functions</h3>
<p>
Generate bogus functions that are virtualized along with the "real"
function. Instructions from the bogus and real function are executed
cyclically and in sequence, i.e. first an instruction from the real function, then
one from bogus function number 1, then one from bogus function number 2, etc., 
and then the process repeats with an instruction from the real 
function. The purpose is to frustrate dynamic analyses that try to
locate the virtual program counter, by providing multiple VPCs,
one "real", and one or more that behave as if they were real, 
but which interpret unused functions:
<center><img width="500px" src="bogus-functions-2.png"></center>
</p>


<!-- -------------------------------------------------------------------------------- -->

<a class="anchor" id="BogusLoops">&nbsp;</a>
<h3>Bogus Loops</h3>
<p>
Add random computations to every iteration of the dispatch loop.  
Use this to frustrate dynamic analysis by 
<ol>
   <li>inserting bogus instructions between consecutive iterations of the dispatch loop, 
       thereby making the dispatch harder to recognize;
   <li>making traces longer and thereby harder to store and analyze.
</ol>
</p>

<!-- -------------------------------------------------------------------------------- -->

<a class="anchor" id="Reentrant">&nbsp;</a>
<h3>Reentrant Interpreters</h3>
<p>
Make interpreters that can execute a few instructions,
return, and later resume to execute a few more instructions,
until, eventually, they terminate. This is particularly
useful when it is not important exactly when
the a piece of code executes, as long as it executes <em>eventually</em>,
and where the stealthiness of the computations is paramount.
</p>

<p>
The result is an instruction trace that intermixes instructions
from the original program and the interpreted function:
<center><img width="500px" src="reentrant-2.png"></center>
</p>

<p>You must prepare your code in the following ways:</p>
<ol>
   <li> <p>The function you want to virtualize must have an argument
        <tt>int* operation</tt>. It can occur anywhere among the formal parameters:</p>
<pre>
void foo(int* operation, int n, int* result) {&hellip;}
</pre>

<!-- --------------------------- -->
   <li> <p>The first time foo gets called, operation must be
        <0, and you must pass actual arguments to foo that
        it will use throughout the computation:</p>
<pre>
int operation = -10; 
foo(&operation,n,&result);
</pre>
       <p>"-10" here means to initialize foo and execute 10
        instructions.</p>
<!-- --------------------------- -->
    <li> <p>Sprinkle calls to foo throughout your program,
         making sure that operation>0:</p>
<pre>
operation = 10;
foo(&operation,bogus1,&bogus2);  
</pre>
         <p>Here you can pass whatever arguments you want to foo, 
         they won't be used. Rather, the ones that were passed 
         in the first call will be used throughout. "10" here 
         means to resume foo and execute 10 instructions.</p>
<!-- --------------------------- -->
   <li> <p>You can check if foo has terminated by testing the
        value of operation after the call:</p>
<pre>
operation = 10;
foo(&operation,bogus1,&bogus2);  
if (operation > 0)
   /* we're done! */
else if (operation < 0)
   /* more work to do! */
</pre>
<!-- --------------------------- -->
   <li> <p>If you want to make sure that foo has terminated
        --- because you really want its result at a particular
          point --- set operation to a large enough value:</p>
<pre>
operation = 1000;
foo(&operation,bogus1,&bogus2);  
</pre>
<!-- --------------------------- -->
   <li> <p>Additional calls to foo once termination has been
        reached is safe; no additional instructions will
        be executed.</p>
<!-- --------------------------- -->
   <li> <p>If you want to call foo to compute a new value, 
        call it again with operation<0:</p>
<pre>
   int operation = -10; 
   foo(&operation,n,&result);
</pre>
</ol>

<p>To ensure termination you can</p>
<ol>
   <li> experiment yourself with how many iterations
        are necessary to finish the computation;
   <li> make sure that the last call to foo is passed a
        huge value to 'operation';
   <li> put the last call to foo in a loop
<pre>
   foo(&operation);   
   while (operation < 0) {
      /* some other computation here */
      operation = 10;
      foo(&operation);   
   } 
   /* result is available here */
</pre>
</ol>

<p>It is a good idea to combine reentrant interpreters with
superoperators. Superoperators produce long instructions
that perform more work during each iteration, and as a
result the number of dispatches (i.e. loop iterations)
is reduced. In other words, if you want to frustrate
dynamic analysis that looks for evidence of the dispatch
loop in the instruction trace, superoperators combined
with reentrant interpreters will reduce the presence of 
such artifacts.</p>

<a class="anchor" id="EncodingProgram">&nbsp;</a>
<h3>Encoding the Program Array</h3>
<p>
Setting
<tt>--VirtualizeEncodeByteArray=true</tt>
results in each program instruction being xor:ed with
a constant value, thus ensuring that it is
not in cleartext until it is run:</p>
<pre>
unsigned char _5_obf3_$array[1][141]  = 
     {{
        (unsigned char)formal$result_STA_0$value_LIT_0 ^ (unsigned char)16,
        (unsigned char)1 ^ (unsigned char)16,
        (unsigned char)0 ^ (unsigned char)16,
        (unsigned char)0 ^ (unsigned char)16,
        (unsigned char)0 ^ (unsigned char)16,
        (unsigned char)load_int$left_STA_0$result_STA_0 ^ (unsigned char)16,
        (unsigned char)formal$result_STA_0$value_LIT_0 ^ (unsigned char)16,
        (unsigned char)0 ^ (unsigned char)16,
        (unsigned char)0 ^ (unsigned char)16,
        (unsigned char)0 ^ (unsigned char)16,
        (unsigned char)0 ^ (unsigned char)16,
        ...
     }}
</pre>
<p>This does not work for <tt>--VirtualizeDispatch=direct</tt>.</p>

<p>Additionally, setting <tt>--VirtualizeObfuscateDecodeByteArray=true</tt> and
<tt>--VirtualizeOpaqueStructs=input,env</tt> ensures that the decoded 
bytecode array depends on input. The decoding procedure looks like this:
<pre>
  strcmp_result17 = (int)strlen(*(argv + (argc - 1)));
  decodeVar16 = (strcmp_result17 - 1 < 0) + (strcmp_result17 - 10 > 0) ? currentOp : (unsigned char)16;
  copyIndex15 = 0;
  while (copyIndex15 < 141) {
    localArrayCopy11[0][copyIndex15] = array[0][copyIndex15] ^ decodeVar16;
    copyIndex15 ++;
  }
  $pc[0] = localArrayCopy11[0];
</pre>
</p>

<p>Here's an example script:</p>
<pre>
tigress --Seed=0 \
   --Transform=InitImplicitFlow \
   --Transform=InitEntropy \
   --Transform=InitOpaque --Functions=main --InitOpaqueStructs=input \
   --Transform=UpdateEntropy --Functions=main --UpdateEntropyVar=argv,argc \
   --Inputs="+1:int:42,-1:length:1?10" \
   --Transform=Virtualize --InitOpaqueStructs=input,env \
   --VirtualizeDispatch=interpolation --Functions=obf3 \
   --VirtualizeEncodeByteArray=true \
   --VirtualizeObfuscateDecodeByteArray=true \
   --VirtualizeOpaqueStructs=input,env \
      arith.c --out=arith_out.c
</pre>
<p><tt>--Inputs="+1:int:42,-1:length:1?10"</tt> is a specfication of invariants over
the command line. It specifies:</p>
<ul>
   <li> the first argument on the command line should be the integer 42</li>
   <li> the last argument should have a length between 1 and 10 </li>
</ul>
<p><tt>--VirtualizeOpaqueStructs=input,env</tt> ensures that the 
program array will be encoded based on these command line invariants.
If the program is invoked with a set of command line arguments that
violate the invariants it is likely to crash.
</p>

<a class="anchor" id="DynamicProgram">&nbsp;</a>
<h3>Dynamic Program Arrays</h3>
<p>
Setting <tt>--VirtualizeDynamicBytecode=true</tt>
results in the program array being constantly modified at runtime,
much in the same way that happens to jitted code in the 
<a href="../jitDynamic/index.html">JitDynamic</a> 
transformation. In fact, exactly the same mechanisms are used
for both transformations, and they share all the same options.</p>

<p>Here's an example script:</p>
<pre>
tigress --Seed=0 \
   --Transform=Virtualize \
      --Functions=foo \
      --VirtualizeDispatch=switch \
      --VirtualizeDynamicBytecode=true \
      --VirtualizeDynamicCodecs=xtea \
      --VirtualizeDynamicKeyTypes=data \
      --VirtualizeDynamicBlockFraction=%100 \
      --VirtualizeDynamicReEncode=true \
      --VirtualizeDynamicRandomizeBlocks=false \
      --VirtualizeDynamicDumpCFG=false \
      --VirtualizeDynamicAnnotateTree=false \
      --VirtualizeDynamicDumpTree=false \
      --VirtualizeDynamicDumpIntermediate=false \
      --VirtualizeDynamicTrace=0 \
      --VirtualizeDynamicTraceExec=false \
      --VirtualizeDynamicTraceBlock=false \
      --VirtualizeDynamicCompileCommand="gcc -o %o %i -lm" \
      arith.c --out=arith_out.c
</pre>

<!-- -------------------------------------------------------------------------------- -->

<a class="anchor" id="options">&nbsp;</a>
<h3>Options</h3>
<table class="deftable">
<tr><th>Option</th><th>Arguments</th><th>Description</th></tr>
<tr>
<td><tt>--Transform</tt></td>
<td><tt>Virtualize</tt></td>
<td> Turn a function into an interpreter. </td>
</tr>
<tr>
<td><tt>--VirtualizeShortIdents</tt></td>
<td><tt>bool</tt></td>
<td> Generate shorter identifiers to produce interpreters suitable for publication. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeIsWindows</tt></td>
<td><tt>bool</tt></td>
<td> Set this to true if you're on Windows rather than a Unix system. Currently only relevant when generating bogus functions. </td>
</tr>
<tr>
<td><tt>--VirtualizeDispatch</tt></td>
<td><tt>switch, direct, indirect, call, ifnest, linear, binary, interpolation, ?</tt></td>
<td> Select the interpreter's dispatch method. The argument should be a comma-separated list of disparch kinds. One of these will be picked at random. Default=switch.
<ul>
   <li> <tt>switch</tt> = dispatch by while(){switch(next){...}}
   <li> <tt>direct</tt> = dispatch by direct threading
   <li> <tt>indirect</tt> = dispatch by indirect threading
   <li> <tt>call</tt> = dispatch by call threading
   <li> <tt>ifnest</tt> = dispatch by nested if-statements
   <li> <tt>linear</tt> = dispatch by searching a table using linear search
   <li> <tt>binary</tt> = dispatch by searching a table using binary search
   <li> <tt>interpolation</tt> = dispatch by searching a table using interpolation search
   <li> <tt>?</tt> = Pick a random dispatch method
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeOperands</tt></td>
<td><tt>stack, registers, mixed, ?</tt></td>
<td> Comma-separated list of the types of operands allowed in the ISA. Default=stack.
<ul>
   <li> <tt>stack</tt> = use stack arguments to instructions
   <li> <tt>registers</tt> = use register arguments to instructions
   <li> <tt>mixed</tt> = same as stack,registers
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeMaxDuplicateOps</tt></td>
<td><tt><a href="http://tigress.cs.arizona.edu/usage.html#arguments">INTSPEC</a></tt></td>
<td> Number of ADD instructions, for example, with different signatures. Default=0.</td>
</tr>
<tr>
<td><tt>--VirtualizeRandomOps</tt></td>
<td><tt>bool</tt></td>
<td> Should opcodes be randomized, or go from 0..n? Default=true.</td>
</tr>
<tr>
<td><tt>--VirtualizeSuperOpsRatio</tt></td>
<td><tt>Float>0.0</tt></td>
<td> Desired number of super operators. Default=0.0.</td>
</tr>
<tr>
<td><tt>--VirtualizeMaxMergeLength</tt></td>
<td><tt><a href="http://tigress.cs.arizona.edu/usage.html#arguments">INTSPEC</a></tt></td>
<td> Longest sequence of instructions to be merged into one. Default=0.</td>
</tr>
<tr>
<td><tt>--VirtualizeInstructionHandlerSplitCount</tt></td>
<td><tt><a href="http://tigress.cs.arizona.edu/usage.html#arguments">INTSPEC</a></tt></td>
<td> Number of opaques to add to each instruction handler. Default=0.</td>
</tr>
<tr>
<td><tt>--VirtualizeAddOpaqueToVPC</tt></td>
<td><tt><a href="http://tigress.cs.arizona.edu/usage.html#arguments">BOOLSPEC</a></tt></td>
<td> Whether to add opaques to the virtual program counter. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeAddOpaqueToBogusFuns</tt></td>
<td><tt><a href="http://tigress.cs.arizona.edu/usage.html#arguments">BOOLSPEC</a></tt></td>
<td> Whether to add opaque expressions to the generated bogus function. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeNumberOfBogusFuns</tt></td>
<td><tt><a href="http://tigress.cs.arizona.edu/usage.html#arguments">INTSPEC</a></tt></td>
<td> Weave the execution of random functions into the execution of the original program. This makes certain kinds of pattern-based dynamic analysis more difficult. Default=0.</td>
</tr>
<tr>
<td><tt>--VirtualizeBogusFunsGenerateOutput</tt></td>
<td><tt><a href="http://tigress.cs.arizona.edu/usage.html#arguments">BOOLSPEC</a></tt></td>
<td> Make the bogus function produce output (typically be writing to /dev/null), to prevent it from appearing to have no effect. Default=true.</td>
</tr>
<tr>
<td><tt>--VirtualizeBogusFunKinds</tt></td>
<td><tt>trivial, arithSeq, collatz, *</tt></td>
<td> The kind of bogus function to generate. Comma-separated list. Default=arithSeq,collatz.
<ul>
   <li> <tt>trivial</tt> = insert a trivial computation
   <li> <tt>arithSeq</tt> = insert a simple arithmetic loop
   <li> <tt>collatz</tt> = insert a computation of the Collatz sequence
   <li> <tt>*</tt> = select all options
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeBogusLoopKinds</tt></td>
<td><tt>trivial, arithSeq, collatz, *</tt></td>
<td> Insert a bogus loop for each instruction list. This will extend the length of the trace, making dynamic analysis more difficult. 
<ul>
   <li> <tt>trivial</tt> = insert a trivial computation
   <li> <tt>arithSeq</tt> = insert a simple arithmetic loop
   <li> <tt>collatz</tt> = insert a computation of the Collatz sequence
   <li> <tt>*</tt> = select all options
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeBogusLoopIterations</tt></td>
<td><tt><a href="http://tigress.cs.arizona.edu/usage.html#arguments">INTSPEC</a></tt></td>
<td> Adjust this value to balance performance and trace length. Default=0.</td>
</tr>
<tr>
<td><tt>--VirtualizePerformance</tt></td>
<td><tt>IndexedStack, PointerStack, AddressSizeShort, AddressSizeInt, AddressSizeLong, CacheTop</tt></td>
<td> Tweak performance. A comma-separated list of the options below. DEFAULT PointerStack 
<ul>
   <li> <tt>IndexedStack</tt> = Use array indexing to access stack elements.
   <li> <tt>PointerStack</tt> = Use pointer operations to access stack elements.
   <li> <tt>AddressSizeShort</tt> = Assume addresses for accessing instruction handlers fit in a short.
   <li> <tt>AddressSizeInt</tt> = Assume addresses for accessing instruction handlers fit in an int.
   <li> <tt>AddressSizeLong</tt> = Assume addresses for accessing instruction handlers fit in a long.
   <li> <tt>CacheTop</tt> = Store the top of stack in a register.
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeReentrant</tt></td>
<td><tt></tt></td>
<td> Make the function reentrant. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeOptimizeBody</tt></td>
<td><tt><a href="http://tigress.cs.arizona.edu/usage.html#arguments">BOOLSPEC</a></tt></td>
<td> Clean up after superoperator generation by optimizing the body of the generated function. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeOptimizeTreeCode</tt></td>
<td><tt><a href="http://tigress.cs.arizona.edu/usage.html#arguments">BOOLSPEC</a></tt></td>
<td> Do constant folding etc. prior to interpreter generation. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeTrace</tt></td>
<td><tt>instr, args, stack, regs, *</tt></td>
<td> Insert tracing code to show the stack and the virtual instructions executing. Default=print nothing.
<ul>
   <li> <tt>instr</tt> = print instruction names
   <li> <tt>args</tt> = print instruction names and arguments
   <li> <tt>stack</tt> = print stack contents (currently only works if you set --VirtualizePerformance=IndexedStack)
   <li> <tt>regs</tt> = print register contents (not implemented)
   <li> <tt>*</tt> = select all options
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeStackSize</tt></td>
<td><tt><a href="http://tigress.cs.arizona.edu/usage.html#arguments">INTSPEC</a></tt></td>
<td> Number of elements in the evaluation stack. Default=32.</td>
</tr>
<tr>
<td><tt>--VirtualizeComment</tt></td>
<td><tt>bool</tt></td>
<td> Insert comments in the generated interpreter. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeDump</tt></td>
<td><tt>tree, ISA, instrs, types, vars, strings, SuperOps, calls, bytes, array, stack, *</tt></td>
<td> Dump internal data structures used by the virtualizer. Comma-separated list. Default=dump nothing.
<ul>
   <li> <tt>tree</tt> = dump the expression trees generated from the CIL representation
   <li> <tt>ISA</tt> = dump the Instruction Set Architecture
   <li> <tt>instrs</tt> = dump the generated virtual instructions
   <li> <tt>types</tt> = dump the types found
   <li> <tt>vars</tt> = dump the local variables found
   <li> <tt>strings</tt> = dump the strings found
   <li> <tt>SuperOps</tt> = dump the super operator instructions
   <li> <tt>calls</tt> = dump the function calls found
   <li> <tt>bytes</tt> = dump the bytecode array
   <li> <tt>array</tt> = dump the instruction array
   <li> <tt>stack</tt> = dump the evaluation stack
   <li> <tt>*</tt> = select all options
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeImplicitFlowPC</tt></td>
<td><tt>PCInit, PCUpdate, *</tt></td>
<td> Insert implicit flow between the virtual program counter and instruction dispatcher. Default=none.
<ul>
   <li> <tt>PCInit</tt> = insert implcit flow between the computation of the VPC address and the first load
   <li> <tt>PCUpdate</tt> = insert implcit flow for each VPC load (potentially very slow)
   <li> <tt>*</tt> = select all options
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeImplicitFlow</tt></td>
<td><tt>S-Expression</tt></td>
<td> The type of implicit flow to insert. See --AntiTaintAnalysisImplicitFlow for a description. Default=none.</td>
</tr>
<tr>
<td><tt>--VirtualizeConditionalKinds</tt></td>
<td><tt>branch, compute, flag</tt></td>
<td> Ways to transform the one conditional branch that occurs in instruction handlers. Default=branch.
<ul>
   <li> <tt>branch</tt> = Use normal branches, such as if (a>b) VPC=L1 else VPC=L2
   <li> <tt>compute</tt> = Compute the branch, such as x=(a>b); VPC=*(expression over x). Not yet implemented.
   <li> <tt>flag</tt> = Compute the branch from the values of the flag register, such as asm("cmp a b;pushf;pop"); VPC=*(expression over flag register)
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeOpaqueStructs</tt></td>
<td><tt>list, array, input, env, *</tt></td>
<td> Default=list,array.
<ul>
   <li> <tt>list</tt> = Generate opaque expressions using linked lists
   <li> <tt>array</tt> = Generate opaque expressions using arrays
   <li> <tt>input</tt> = Generate opaque expressions that depend on input. Requires --Inputs to set invariants over input.
   <li> <tt>env</tt> = Generate opaque expressions from entropy. Requires --InitEntropy.
   <li> <tt>*</tt> = Same as list,array,input,env
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeEncodeByteArray</tt></td>
<td><tt>bool</tt></td>
<td> Encode the bytecode array. It is decoded before the interpreter is entered. Doesn't work for direct dispatch. Requires opaque expressions. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeObfuscateDecodeByteArray</tt></td>
<td><tt>bool</tt></td>
<td> Obfuscates the program array decoded with opaque expressions. --VirtualizeOpaqueStructs=input,env are the preferable opaque kinds, since it means that the bytecode array depends on input. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicBytecode</tt></td>
<td><tt>BOOL</tt></td>
<td> Similar to the JitDynamic transform, make the virtualized bytecode self-modifying. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicEncoding</tt></td>
<td><tt>hard, soft</tt></td>
<td> How the jitted instructions are encoded. Default=hard.
<ul>
   <li> <tt>hard</tt> = The jitted instructions are encoded as code.
   <li> <tt>soft</tt> = The jitted instructions are encoded as data (not implemented).
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicOptimize</tt></td>
<td><tt><a href="http://tigress.cs.arizona.edu/usage.html#arguments">BOOLSPEC</a></tt></td>
<td> Clean up the generated code by removing jumps-to-jumps. Default=true.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicTrace</tt></td>
<td><tt><a href="http://tigress.cs.arizona.edu/usage.html#arguments">INTSPEC</a></tt></td>
<td> Insert runtime tracing of instructions. Set to 1 to turn it on. Default=0.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicTraceExec</tt></td>
<td><tt><a href="http://tigress.cs.arizona.edu/usage.html#arguments">BOOLSPEC</a></tt></td>
<td> Annotate each instruction, showing from where it was generated, and the results of execution. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicDumpTree</tt></td>
<td><tt><a href="http://tigress.cs.arizona.edu/usage.html#arguments">BOOLSPEC</a></tt></td>
<td> Print the tree representation of the function, prior to generating the jitting code. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicAnnotateTree</tt></td>
<td><tt><a href="http://tigress.cs.arizona.edu/usage.html#arguments">BOOLSPEC</a></tt></td>
<td> Annotate the generated code with the corresponding intermediate tree code instructions. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicCodecs</tt></td>
<td><tt>none, ident, ident_loop, xor_transfer, xor_byte_loop, xor_word_loop, xor_qword_loop, xor_call, xor_call_trace, xtea, xtea_trace, stolen_byte, stolen_short, stolen_word</tt></td>
<td> How blocks should be encoded/decoded. Default=*.
<ul>
   <li> <tt>none</tt> = No encoding
   <li> <tt>ident</tt> = The identity encoding using a single copy JIT instruction
   <li> <tt>ident_loop</tt> = The identity encoding using a copy loop of primitive JIT instructions
   <li> <tt>xor_transfer</tt> = An xor encoding using a single xor JIT instruction
   <li> <tt>xor_byte_loop</tt> = An xor encoding using a copy loop of byte-size primitive JIT instructions
   <li> <tt>xor_word_loop</tt> = An xor encoding using a copy loop of word-size primitive JIT instructions
   <li> <tt>xor_qword_loop</tt> = An xor encoding using a copy loop of qword-size primitive JIT instructions
   <li> <tt>xor_call</tt> = An xor encoding calling a xor function
   <li> <tt>xor_call_trace</tt> = An xor encoding calling a xor function with tracing turned on (for debugging)
   <li> <tt>xtea</tt> = An xtea encryption
   <li> <tt>xtea_trace</tt> = An xtea encryption with tracing turned on (for debugging)
   <li> <tt>stolen_byte</tt> = A byte-sized stolen bytes encoding
   <li> <tt>stolen_short</tt> = A short-sized stolen bytes encoding
   <li> <tt>stolen_word</tt> = A word-sized stolen bytes encoding
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicKeyTypes</tt></td>
<td><tt>data, code</tt></td>
<td> Where the encoding/decoding key is stored (for xor and xtea encodings) Default=data.
<ul>
   <li> <tt>data</tt> = In the data segment
   <li> <tt>code</tt> = In the code segment (not implemented)
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicBlockFraction</tt></td>
<td><tt><a href="http://tigress.cs.arizona.edu/usage.html#arguments">FRACSPEC</a></tt></td>
<td> Fraction of the basic blocks in a function to encode Default=all.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicRandomizeBlocks</tt></td>
<td><tt><a href="http://tigress.cs.arizona.edu/usage.html#arguments">BOOLSPEC</a></tt></td>
<td> Randomize the order of basic blocks Default=true.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicReEncode</tt></td>
<td><tt><a href="http://tigress.cs.arizona.edu/usage.html#arguments">BOOLSPEC</a></tt></td>
<td> If true, blocks will be re-encoded after being executed. If false, blocks will be decoded once, and stay in cleartext. ('False' is not implemented; this option is always set to 'true'.) Default=true.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicDumpCFG</tt></td>
<td><tt><a href="http://tigress.cs.arizona.edu/usage.html#arguments">BOOLSPEC</a></tt></td>
<td> Print the jitter's Control Flow Graph. This requires graphviz to be installed (the dot command is used). A number of pdf files get generated that shows the CFG at various stages of processing: CFGAfterInsertingAnnotations.pdf, CFGAfterSimplifyingJumps.pdf, CFGAfterTranslatingAnnotations.pdf, CFGBeforeInsertingAnnotations.pdf, CFGDumpingFunctionFinal.pdf, CFGDumpingFunctionInitial.pdf, CFGFixupIndirecJumps.pdf, CFGReplaceWithCompiledBlock.pdf, CFGSplitOutBranches.pdf, CFGSplitOutDataReferences.pdf, OriginalCFG.pdf Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicTraceBlock</tt></td>
<td><tt><a href="http://tigress.cs.arizona.edu/usage.html#arguments">BOOLSPEC</a></tt></td>
<td> Print out a message before each block is executed. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicTraceBlock</tt></td>
<td><tt>STRING</tt></td>
<td> Print out a message before each block is executed. (Not currently implemented.) Default="".</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicCompileCommand</tt></td>
<td><tt>STRING</tt></td>
<td> A string of the form "gcc -std=c99 -o %o %i", where "%i" will be replaced with the name of the input file and "%o" with the name of the output file. For example, if your program uses the math library, you should set --VirtualizeDynamicCompileCommand="gcc -std=c99 -o %o %i -lm". Default="gcc -std=c99 -o %o %i".</td>
</tr>
</table>


<a class="anchor" id="examples">&nbsp;</a>
<H3>Examples</H3>
<p>As you are reading the code, there are a couple of interesting things to note:</p>
<ul>
   <li> Much of the symbolic information present in the transformed
        source files (such as types, enumerations, and structured
        control flow) that help make the code easy to read and
        understand, disappears once the source has been compiled,
        linked, and stripped.  A successful attack will (at least partially) 
        have to recover this information.
   <li> The code after <em>two</em> levels of virtualization looks very similar to
        the code after <em>one</em> level of virtualization. This is because the
        dispatch loop of the first virtualization gets coded into the bytecode
        program of the second. It's an interesting question to ask to what
        extent this hinders de-virtualization.
   <li> The <tt>direct</tt> and <tt>call</tt> dispatch methods result
        in much larger bytecode programs than the other methods. This
        is particularly evident on 64-bit machines where every opcode
        gets encoded in 8 bytes, in contrast with a single byte for
        the other methods. For this reason, if you are contemplating
        using two levels of interpretation, it's a good idea to make
        the second level <em>not</em> use <tt>direct</tt> or <tt>call</tt>
        dispatch, to keep the size of the program down. Future versions
        of Tigress will use more compact encodings for these types of
        dispatch.
</ul>

<table class="exampletable">
   <tr>
      <th>
         Virtualize
      </th>
   </tr>
   <tr>
      <td>
         Virtualize <tt>fib</tt> in <a href="test1.c">test1.c</a> using each of the
         dispatch methods.
      </td>
   </tr>
   <tr>
      <td>
<pre>
tigress --Environment=x86_64:Darwin:Clang:5.1 --Verbosity=1  \
   --Transform=Virtualize --Functions=fib --VirtualizeDispatch=<em>dispatch</em> \
   --Transform=CleanUp --CleanUpKinds=annotations \
   --out=gen/... test1.c 
</pre>
      </td>
   </tr>
</table>

<table class="virttable">
<tr>
   <th>sw</th>
   <th>if</th>
   <th>di</th>
   <th>id</th>
   <th>ca</th>
   <th>li</th>
   <th>bi</th>
   <th>ip</th>
</tr>
<tr>
   <td><a href="gen/v1/virtualize_switch.sh.txt">sh</a> &rArr; <a href="gen/v1/virtualize_switch.c">out.c</a></td>
   <td><a href="gen/v1/virtualize_ifnest.sh.txt">sh</a> &rArr; <a href="gen/v1/virtualize_ifnest.c">out.c</a></td>
   <td><a href="gen/v1/virtualize_direct.sh.txt">sh</a> &rArr; <a href="gen/v1/virtualize_direct.c">out.c</a></td>
   <td><a href="gen/v1/virtualize_indirect.sh.txt">sh</a> &rArr; <a href="gen/v1/virtualize_indirect.c">out.c</a></td>
   <td><a href="gen/v1/virtualize_call.sh.txt">sh</a> &rArr; <a href="gen/v1/virtualize_call.c">out.c</a></td>
   <td><a href="gen/v1/virtualize_linear.sh.txt">sh</a> &rArr; <a href="gen/v1/virtualize_linear.c">out.c</a></td>
   <td><a href="gen/v1/virtualize_binary.sh.txt">sh</a> &rArr; <a href="gen/v1/virtualize_binary.c">out.c</a></td>
   <td><a href="gen/v1/virtualize_interpolation.sh.txt">sh</a> &rArr; <a href="gen/v1/virtualize_interpolation.c">out.c</a></td>
</tr>
</table>

<p />
<!-- -------------------------------------------------------------------------------- -->
<table class="exampletable">
   <tr>
      <th>
         Virtualize &rArr; Virtualize
      </th>
   </tr>
   <tr>
      <td>
         Virtualize <tt>fib</tt> in <a href="test1.c">test1.c</a> using two
         levels of interepretation.
      </td>
   </tr>
   <tr>
      <td>
<pre>
tigress --Environment=x86_64:Darwin:Clang:5.1 --Verbosity=1  \
   --Transform=Virtualize --Functions=fib --VirtualizeDispatch=<em>dispatch1</em> \
   --Transform=Virtualize --Functions=fib --VirtualizeDispatch=<em>dispatch2</em> \
   --Transform=CleanUp --CleanUpKinds=annotations \
   --out=gen/... test1.c 
</pre>
      </td>
   </tr>
</table>

<table class="virttable">
<tr>
<th></th>
   <th>sw</th>
   <th>if</th>
   <th>di</th>
   <th>id</th>
   <th>ca</th>
   <th>li</th>
   <th>bi</th>
   <th>ip</th>
</tr>
<tr>
   <th>sw</th>
   <td><a href="gen/v2/virtualize_switch_switch.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_switch_switch.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_switch_ifnest.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_switch_ifnest.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_switch_direct.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_switch_direct.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_switch_indirect.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_switch_indirect.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_switch_call.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_switch_call.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_switch_linear.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_switch_linear.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_switch_binary.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_switch_binary.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_switch_interpolation.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_switch_interpolation.c">out.c</a></td>
</tr>
<tr>
   <th>if</th>
   <td><a href="gen/v2/virtualize_ifnest_switch.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_ifnest_switch.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_ifnest_ifnest.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_ifnest_ifnest.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_ifnest_direct.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_ifnest_direct.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_ifnest_indirect.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_ifnest_indirect.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_ifnest_call.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_ifnest_call.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_ifnest_linear.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_ifnest_linear.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_ifnest_binary.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_ifnest_binary.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_ifnest_interpolation.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_ifnest_interpolation.c">out.c</a></td>
</tr>
<tr>
   <th>di</th>
   <td><a href="gen/v2/virtualize_direct_switch.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_direct_switch.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_direct_ifnest.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_direct_ifnest.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_direct_direct.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_direct_direct.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_direct_indirect.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_direct_indirect.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_direct_call.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_direct_call.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_direct_linear.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_direct_linear.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_direct_binary.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_direct_binary.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_direct_interpolation.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_direct_interpolation.c">out.c</a></td>
</tr>
<tr>
   <th>id</th>
   <td><a href="gen/v2/virtualize_indirect_switch.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_indirect_switch.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_indirect_ifnest.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_indirect_ifnest.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_indirect_direct.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_indirect_direct.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_indirect_indirect.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_indirect_indirect.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_indirect_call.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_indirect_call.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_indirect_linear.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_indirect_linear.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_indirect_binary.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_indirect_binary.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_indirect_interpolation.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_indirect_interpolation.c">out.c</a></td>
</tr>
<tr>
   <th>ca</th>
   <td><a href="gen/v2/virtualize_call_switch.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_call_switch.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_call_ifnest.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_call_ifnest.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_call_direct.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_call_direct.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_call_indirect.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_call_indirect.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_call_call.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_call_call.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_call_linear.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_call_linear.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_call_binary.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_call_binary.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_call_interpolation.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_call_interpolation.c">out.c</a></td>
</tr>
<tr>
   <th>li</th>
   <td><a href="gen/v2/virtualize_linear_switch.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_linear_switch.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_linear_ifnest.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_linear_ifnest.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_linear_direct.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_linear_direct.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_linear_indirect.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_linear_indirect.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_linear_call.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_linear_call.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_linear_linear.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_linear_linear.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_linear_binary.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_linear_binary.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_linear_interpolation.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_linear_interpolation.c">out.c</a></td>
</tr>
<tr>
   <th>bi</th>
   <td><a href="gen/v2/virtualize_binary_switch.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_binary_switch.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_binary_ifnest.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_binary_ifnest.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_binary_direct.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_binary_direct.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_binary_indirect.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_binary_indirect.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_binary_call.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_binary_call.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_binary_linear.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_binary_linear.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_binary_binary.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_binary_binary.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_binary_interpolation.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_binary_interpolation.c">out.c</a></td>
</tr>
<tr>
   <th>ip</th>
   <td><a href="gen/v2/virtualize_interpolation_switch.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_interpolation_switch.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_interpolation_ifnest.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_interpolation_ifnest.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_interpolation_direct.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_interpolation_direct.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_interpolation_indirect.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_interpolation_indirect.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_interpolation_call.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_interpolation_call.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_interpolation_linear.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_interpolation_linear.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_interpolation_binary.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_interpolation_binary.c">out.c</a></td>
   <td><a href="gen/v2/virtualize_interpolation_interpolation.sh.txt">sh</a> &rArr; <a href="gen/v2/virtualize_interpolation_interpolation.c">out.c</a></td>
</tr>
</table>

<p />
<!-- -------------------------------------------------------------------------------- -->

<table class="exampletable">
   <tr>
      <th>
         Virtualize
      </th>
   </tr>
   <tr>
      <td>
         Virtualize <tt>fib</tt> using a switch dispatch, mixed register
         and stack arguments, and at most two instruction variants of each
         kind (i.e., no more than 2 ADD instructions, etc.).
      </td>
   </tr>
   <tr>
      <td>
<pre>
tigress --Environment=x86_64:Darwin:Clang:5.1 --Verbosity=1  \
   --Transform=Virtualize --Functions=fib --VirtualizeDispatch=switch \
   --VirtualizeMaxDuplicateOps=2 --VirtualizeOperands=mixed \
   --Transform=CleanUp --CleanUpKinds=annotations \
   --out=gen/virtualize_mixed.c test1.c 
</pre>
      </td>
   </tr>
   <tr>
      <td>
         <a href="test1.c">test1.c</a> 
         &rArr;
         <a href="virtualize_mixed.sh.txt">virtualize_mixed.sh.txt</a>
         &rArr;
         <a href="gen/virtualize_mixed.c">virtualize_mixed.c</a>
      </td>
   </tr>
</table>
<p />
<!-- -------------------------------------------------------------------------------- -->

<table class="exampletable">
   <tr>
      <th>
         Virtualize
      </th>
   </tr>
   <tr>
      <td>
         Virtualize <tt>fib</tt> using a switch dispatch, register
         and stack arguments, at most two instruction variants of each
         kind, and superoperators of length no more than 10.
      </td>
   </tr>
   <tr>
      <td>
<pre>
tigress --Environment=x86_64:Darwin:Clang:5.1 --Verbosity=1  \
   --Transform=Virtualize --Functions=fib --VirtualizeDispatch=switch \
   --VirtualizeMaxDuplicateOps=2 --VirtualizeOperands=mixed \
   --VirtualizeSuperOpsRatio=2.0 --VirtualizeMaxMergeLength=10 \
   --VirtualizeOptimizeBody=true \
   --Transform=CleanUp --CleanUpKinds=annotations \
   --out=gen/virtualize_super.c test1.c 
</pre>
      </td>
   </tr>
   <tr>
      <td>
         <a href="test1.c">test1.c</a> 
         &rArr;
         <a href="virtualize_super.sh.txt">virtualize_super.sh.txt</a>
         &rArr;
         <a href="gen/virtualize_super.c">virtualize_super.c</a>
      </td>
   </tr>
</table>

<p />
<!-- -------------------------------------------------------------------------------- -->

<table class="exampletable">
   <tr>
      <th>
         Virtualize
      </th>
   </tr>
   <tr>
      <td>
         Virtualize <tt>fib</tt> using a switch dispatch, register
         and stack arguments, at most two instruction variants of each
         kind, obfuscate operators of length no more than 10, add 
         opaque expressions to the dispatch, and split up instruction
         handlers using opaque predicates.
      </td>
   </tr>
   <tr>
      <td>
<pre>
tigress --Environment=x86_64:Darwin:Clang:5.1 --Verbosity=1  \
   --Transform=InitOpaque --Functions=main \
   --Transform=Virtualize --Functions=fib --VirtualizeDispatch=switch \
   --VirtualizeMaxDuplicateOps=2 --VirtualizeOperands=mixed \
   --VirtualizeSuperOpsRatio=2.0 --VirtualizeMaxMergeLength=10 \
   --VirtualizeOptimizeBody=true \
   --VirtualizeMaxOpaque=5\
   --Transform=CleanUp --CleanUpKinds=annotations \
   --out=gen/virtualize_obfuscate.c test1.c 
</pre>
      </td>
   </tr>
   <tr>
      <td>
         <a href="test1.c">test1.c</a> 
         &rArr;
         <a href="virtualize_obfuscate.sh.txt">virtualize_obfuscate.sh.txt</a>
         &rArr;
         <a href="gen/virtualize_obfuscate.c">virtualize_obfuscate.c</a>
      </td>
   </tr>
</table>

<p />
<!-- -------------------------------------------------------------------------------- -->

<table class="exampletable">
   <tr>
      <th>
         Virtualize
      </th>
   </tr>
   <tr>
      <td>
         Virtualize <tt>fib</tt> using an interpolation dispatch,
         running a bogus function in parallel (to thwart virtual PC
         pattern matching attempts), and inserting bogus computation
         between instruction executions (to increase the length of
         instruction traces).
      </td>
   </tr>
   <tr>
      <td>
<pre>
tigress --Environment=x86_64:Darwin:Clang:5.1 --Verbosity=1  \
   --Transform=InitEntropy --Functions=main \
   --Transform=UpdateEntropy --Functions=fac --UpdateEntropyVar=n \
   --Transform=Virtualize --Functions=fib --VirtualizeDispatch=interpolation \
   --VirtualizeNumberOfBogusFuns=1 --VirtualizeBogusFunKinds=collatz \
   --VirtualizeBogusLoopIterations=10 --VirtualizeBogusLoopKinds=collatz \
   --Transform=CleanUp --CleanUpKinds=annotations \
   --out=gen/virtualize_bogus.c test1.c 
</pre>
      </td>
   </tr>
   <tr>
      <td>
         <a href="test1.c">test1.c</a> 
         &rArr;
         <a href="virtualize_bogus.sh.txt">virtualize_bogus.sh.txt</a>
         &rArr;
         <a href="gen/virtualize_bogus.c">virtualize_bogus.c</a>
      </td>
   </tr>
</table>

<p />
<!-- -------------------------------------------------------------------------------- -->

<table class="exampletable">
   <tr>
      <th>
         Virtualize
      </th>
   </tr>
   <tr>
      <td>
         Virtualize <tt>fib</tt> using an ifnest dispatch,
         and make it reentrant, i.e. call <tt>fib</tt> from multiple
         places in the program, executing a few instructions at a time,
         to make the trace less conspicuous. Make as long superoperators
         as possible, to further reduce the number of times the dispatch
         loop executes.
      </td>
   </tr>
   <tr>
      <td>
<pre>
tigress --Environment=x86_64:Darwin:Clang:5.1 --Verbosity=1  \
   --Transform=Virtualize --Functions=fib --VirtualizeDispatch=ifnest \
   --VirtualizeSuperOpsRatio=2.0 --VirtualizeMaxMergeLength=20 \
   --VirtualizeReentrant=true \
   --Transform=CleanUp --CleanUpKinds=annotations \
   --out=gen/virtualize_reentrant.c test2.c 
</pre>
      </td>
   </tr>
   <tr>
      <td>
         <a href="test2.c">test2.c</a> 
         &rArr;
         <a href="virtualize_reentrant.sh.txt">virtualize_reentrant.sh.txt</a>
         &rArr;
         <a href="gen/virtualize_reentrant.c">virtualize_reentrant.c</a>
      </td>
   </tr>
</table>

<p />
<!-- -------------------------------------------------------------------------------- -->
<table class="exampletable">
   <tr>
      <th>
         Virtualize &rArr; Virtualize
      </th>
   </tr>
   <tr>
      <td>
         Virtualize <tt>fib</tt> twice, calling Tigress twice from the command line.
         Use the <tt>--FilePrefix</tt> option to avoid name clashes.
      </td>
   </tr>
   <tr>
      <td>
<pre>
tigress --Environment=x86_64:Darwin:Clang:5.1 --Verbosity=1 --FilePrefix=x \
   --FilePrefix=v1 \
   --Transform=Virtualize --Functions=fib --VirtualizeDispatch=ifnest \
   --Transform=CleanUp --CleanUpKinds=annotations \
   --out=gen/v1.c test1.c

tigress --Environment=x86_64:Darwin:Clang:5.1 --Verbosity=1 --FilePrefix=x \
   --FilePrefix=v2 \
   --Transform=Virtualize --Functions=fib --VirtualizeDispatch=ifnest \
   --Transform=CleanUp --CleanUpKinds=annotations \
   --out=gen/virtualize-virtualize-prefix.c gen/v1.c
</pre>
      </td>
   </tr>
   <tr>
      <td>
         <a href="test1.c">test1.c</a> 
         &rArr;
         <a href="virtualize-virtualize-prefix.sh.txt">virtualize-virtualize-prefix.sh.txt</a>
         &rArr;
         <a href="gen/virtualize-virtualize-prefix.c">virtualize-virtualize-prefix.c</a>
      </td>
   </tr>
</table>
<p />

<table class="exampletable">
   <tr>
      <th>
         Virtualize &rArr; Split
      </th>
   </tr>
   <tr>
      <td>
         Virtualize <tt>fib</tt>, and split up the resulting function
         in order to make the dispatch loop more statically stealthy.
      </td>
   </tr>
   <tr>
      <td>
<pre>
tigress --Environment=x86_64:Darwin:Clang:5.1 --Verbosity=1  \
   --Transform=Virtualize --Functions=fib --VirtualizeDispatch=switch \
   --VirtualizeMaxDuplicateOps=2 --VirtualizeOperands=mixed \
   --VirtualizeSuperOpsRatio=2.0 --VirtualizeMaxMergeLength=10 \
   --VirtualizeOptimizeBody=true \
   --Transform=Split --Seed=0 --SplitKinds=deep,block,top --SplitCount=100 --Functions=fib \
   --Transform=CleanUp --CleanUpKinds=annotations \
   --out=gen/virtualize-split.c test1.c 
</pre>
      </td>
   </tr>
   <tr>
      <td>
         <a href="examples/test1.c">test1.c</a> 
         &rArr;
         <a href="virtualize-split.sh.txt">.virtualize-split.sh.txt</a>
         &rArr;
         <a href="gen/virtualize-split.c">virtualize-split.c</a>
      </td>
   </tr>
</table>

<p />
<!-- -------------------------------------------------------------------------------- -->

<table class="exampletable">
   <tr>
      <th>
         Virtualize &rArr; Flatten
      </th>
   </tr>
   <tr>
      <td>
         Virtualize <tt>fib</tt> using an ifnest dispatch and flatten
         the resulting function using a goto dispatch.
      </td>
   </tr>
   <tr>
      <td>
<pre>
tigress --Environment=x86_64:Darwin:Clang:5.1 --Verbosity=1  \
   --Transform=InitEntropy --Functions=main \
   --Transform=InitOpaque --Functions=main --InitOpaqueStructs=array \
   --Transform=Virtualize --Functions=fib --VirtualizeDispatch=ifnest \
   --Transform=Flatten --Functions=fib   --FlattenObfuscateNext=true --FlattenDispatch=goto \
   --Transform=CleanUp --CleanUpKinds=annotations \
   --out=gen/virtualize-flatten.c test1.c 
</pre>
      </td>
   </tr>
   <tr>
      <td>
         <a href="test1.c">test1.c</a> 
         &rArr;
         <a href="irtualize-flatten.sh.txt">.virtualize-flatten.sh.txt</a>
         &rArr;
         <a href="gen/virtualize-flatten.c">virtualize-flatten.c</a>
      </td>
   </tr>
</table>

<a class="anchor" id="issues">&nbsp;</a>
<h3>Issues</h3>
<ul>
   <li> <p>Several dispatch methods make use of <tt>gcc's</tt> and <tt>clang</tt>
        <em>labels-as-values</em>. For other compilers only
        the <tt>switch</tt> and <tt>ifnest</tt> dispatch methods should be
        used.</p>
   <li> <tt>--VirtualizeEncodeByteArray=true</tt> does not work for the <em>direct</em>
        dispatch method.
   <li> <p>Our current implementation of reentrant interpreters doesn't handle function
        results, so make sure your function is void, and returns the result in a global 
        or in a formal parameter.</p>
   <li> The <tt>--VirtualizeConditionalKinds=flag</tt> option seems to have
        multiple issues on MacOS/llvm. Presumably this is due to some compiler 
        problem related to inline assembly.
   <li> Consider this example taken from gcc's <tt>comp-goto-1.c</tt> torture test:
<pre>
goto *(base_addr + insn.f1.offset);
</pre>
      This kind of arithmetic on the program counter is going to fail for 
      transformations that completely restructure the code, such as
      virtualization.
</ul>
</body>
</html>

