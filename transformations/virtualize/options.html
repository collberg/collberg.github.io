<table class="deftable">
<tr><th>Option</th><th>Arguments</th><th>Description</th></tr>
<tr>
<td><tt>--Transform</tt></td>
<td><tt>Virtualize</tt></td>
<td> Turn a function into an interpreter. </td>
</tr>
<tr>
<td><tt>--VirtualizeShortIdents</tt></td>
<td><tt>bool</tt></td>
<td> Generate shorter identifiers to produce interpreters suitable for publication. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeIsWindows</tt></td>
<td><tt>bool</tt></td>
<td> Set this to true if you're on Windows rather than a Unix system. Currently only relevant when generating bogus functions. </td>
</tr>
<tr>
<td><tt>--VirtualizeDispatch</tt></td>
<td><tt>switch, direct, indirect, call, ifnest, linear, binary, interpolation, ?</tt></td>
<td> Select the interpreter's dispatch method. The argument should be a comma-separated list of disparch kinds. One of these will be picked at random. Default=switch.
<ul>
   <li> <tt>switch</tt> = dispatch by while(){switch(next){...}}
   <li> <tt>direct</tt> = dispatch by direct threading
   <li> <tt>indirect</tt> = dispatch by indirect threading
   <li> <tt>call</tt> = dispatch by call threading
   <li> <tt>ifnest</tt> = dispatch by nested if-statements
   <li> <tt>linear</tt> = dispatch by searching a table using linear search
   <li> <tt>binary</tt> = dispatch by searching a table using binary search
   <li> <tt>interpolation</tt> = dispatch by searching a table using interpolation search
   <li> <tt>?</tt> = Pick a random dispatch method
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeOperands</tt></td>
<td><tt>stack, registers, mixed, ?</tt></td>
<td> Comma-separated list of the types of operands allowed in the ISA. Default=stack.
<ul>
   <li> <tt>stack</tt> = use stack arguments to instructions
   <li> <tt>registers</tt> = use register arguments to instructions
   <li> <tt>mixed</tt> = same as stack,registers
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeMaxDuplicateOps</tt></td>
<td><tt>INTSPEC</tt></td>
<td> Number of ADD instructions, for example, with different signatures. Default=0.</td>
</tr>
<tr>
<td><tt>--VirtualizeRandomOps</tt></td>
<td><tt>bool</tt></td>
<td> Should opcodes be randomized, or go from 0..n? Default=true.</td>
</tr>
<tr>
<td><tt>--VirtualizeSuperOpsRatio</tt></td>
<td><tt>Float>0.0</tt></td>
<td> Desired number of super operators. Default=0.0.</td>
</tr>
<tr>
<td><tt>--VirtualizeMaxMergeLength</tt></td>
<td><tt>INTSPEC</tt></td>
<td> Longest sequence of instructions to be merged into one. Default=0.</td>
</tr>
<tr>
<td><tt>--VirtualizeInstructionHandlerSplitCount</tt></td>
<td><tt>INTSPEC</tt></td>
<td> Number of opaques to add to each instruction handler. Default=0.</td>
</tr>
<tr>
<td><tt>--VirtualizeAddOpaqueToVPC</tt></td>
<td><tt>BOOLSPEC</tt></td>
<td> Whether to add opaques to the virtual program counter. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeAddOpaqueToBogusFuns</tt></td>
<td><tt>BOOLSPEC</tt></td>
<td> Whether to add opaque expressions to the generated bogus function. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeNumberOfBogusFuns</tt></td>
<td><tt>INTSPEC</tt></td>
<td> Weave the execution of random functions into the execution of the original program. This makes certain kinds of pattern-based dynamic analysis more difficult. Default=0.</td>
</tr>
<tr>
<td><tt>--VirtualizeBogusFunsGenerateOutput</tt></td>
<td><tt>BOOLSPEC</tt></td>
<td> Make the bogus function produce output (typically be writing to /dev/null), to prevent it from appearing to have no effect. Default=true.</td>
</tr>
<tr>
<td><tt>--VirtualizeBogusFunKinds</tt></td>
<td><tt>trivial, arithSeq, collatz, *</tt></td>
<td> The kind of bogus function to generate. Comma-separated list. Default=arithSeq,collatz.
<ul>
   <li> <tt>trivial</tt> = insert a trivial computation
   <li> <tt>arithSeq</tt> = insert a simple arithmetic loop
   <li> <tt>collatz</tt> = insert a computation of the Collatz sequence
   <li> <tt>*</tt> = select all options
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeBogusLoopKinds</tt></td>
<td><tt>trivial, arithSeq, collatz, *</tt></td>
<td> Insert a bogus loop for each instruction list. This will extend the length of the trace, making dynamic analysis more difficult. 
<ul>
   <li> <tt>trivial</tt> = insert a trivial computation
   <li> <tt>arithSeq</tt> = insert a simple arithmetic loop
   <li> <tt>collatz</tt> = insert a computation of the Collatz sequence
   <li> <tt>*</tt> = select all options
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeBogusLoopIterations</tt></td>
<td><tt>INTSPEC</tt></td>
<td> Adjust this value to balance performance and trace length. Default=0.</td>
</tr>
<tr>
<td><tt>--VirtualizePerformance</tt></td>
<td><tt>IndexedStack, PointerStack, AddressSizeShort, AddressSizeInt, AddressSizeLong, CacheTop</tt></td>
<td> Tweak performance. A comma-separated list of the options below. DEFAULT PointerStack 
<ul>
   <li> <tt>IndexedStack</tt> = Use array indexing to access stack elements.
   <li> <tt>PointerStack</tt> = Use pointer operations to access stack elements.
   <li> <tt>AddressSizeShort</tt> = Assume addresses for accessing instruction handlers fit in a short.
   <li> <tt>AddressSizeInt</tt> = Assume addresses for accessing instruction handlers fit in an int.
   <li> <tt>AddressSizeLong</tt> = Assume addresses for accessing instruction handlers fit in a long.
   <li> <tt>CacheTop</tt> = Store the top of stack in a register.
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeReentrant</tt></td>
<td><tt></tt></td>
<td> Make the function reentrant. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeOptimizeBody</tt></td>
<td><tt>BOOLSPEC</tt></td>
<td> Clean up after superoperator generation by optimizing the body of the generated function. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeOptimizeTreeCode</tt></td>
<td><tt>BOOLSPEC</tt></td>
<td> Do constant folding etc. prior to interpreter generation. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeTrace</tt></td>
<td><tt>instr, args, stack, regs, *</tt></td>
<td> Insert tracing code to show the stack and the virtual instructions executing. Default=print nothing.
<ul>
   <li> <tt>instr</tt> = print instruction names
   <li> <tt>args</tt> = print instruction names and arguments
   <li> <tt>stack</tt> = print stack contents (currently only works if you set --VirtualizePerformance=IndexedStack)
   <li> <tt>regs</tt> = print register contents (not implemented)
   <li> <tt>*</tt> = select all options
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeStackSize</tt></td>
<td><tt>INTSPEC</tt></td>
<td> Number of elements in the evaluation stack. Default=32.</td>
</tr>
<tr>
<td><tt>--VirtualizeComment</tt></td>
<td><tt>bool</tt></td>
<td> Insert comments in the generated interpreter. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeDump</tt></td>
<td><tt>tree, ISA, instrs, types, vars, strings, SuperOps, calls, bytes, array, stack, *</tt></td>
<td> Dump internal data structures used by the virtualizer. Comma-separated list. Default=dump nothing.
<ul>
   <li> <tt>tree</tt> = dump the expression trees generated from the CIL representation
   <li> <tt>ISA</tt> = dump the Instruction Set Architecture
   <li> <tt>instrs</tt> = dump the generated virtual instructions
   <li> <tt>types</tt> = dump the types found
   <li> <tt>vars</tt> = dump the local variables found
   <li> <tt>strings</tt> = dump the strings found
   <li> <tt>SuperOps</tt> = dump the super operator instructions
   <li> <tt>calls</tt> = dump the function calls found
   <li> <tt>bytes</tt> = dump the bytecode array
   <li> <tt>array</tt> = dump the instruction array
   <li> <tt>stack</tt> = dump the evaluation stack
   <li> <tt>*</tt> = select all options
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeImplicitFlowPC</tt></td>
<td><tt>PCInit, PCUpdate, *</tt></td>
<td> Insert implicit flow between the virtual program counter and instruction dispatcher. Default=none.
<ul>
   <li> <tt>PCInit</tt> = insert implcit flow between the computation of the VPC address and the first load
   <li> <tt>PCUpdate</tt> = insert implcit flow for each VPC load (potentially very slow)
   <li> <tt>*</tt> = select all options
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeImplicitFlow</tt></td>
<td><tt>S-Expression</tt></td>
<td> The type of implicit flow to insert. See --AntiTaintAnalysisImplicitFlow for a description. Default=none.</td>
</tr>
<tr>
<td><tt>--VirtualizeConditionalKinds</tt></td>
<td><tt>branch, compute, flag</tt></td>
<td> Ways to transform the one conditional branch that occurs in instruction handlers. Default=branch.
<ul>
   <li> <tt>branch</tt> = Use normal branches, such as if (a>b) VPC=L1 else VPC=L2
   <li> <tt>compute</tt> = Compute the branch, such as x=(a>b); VPC=*(expression over x). Not yet implemented.
   <li> <tt>flag</tt> = Compute the branch from the values of the flag register, such as asm("cmp a b;pushf;pop"); VPC=*(expression over flag register)
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeOpaqueStructs</tt></td>
<td><tt>list, array, input, env, *</tt></td>
<td> Default=list,array.
<ul>
   <li> <tt>list</tt> = Generate opaque expressions using linked lists
   <li> <tt>array</tt> = Generate opaque expressions using arrays
   <li> <tt>input</tt> = Generate opaque expressions that depend on input. Requires --Inputs to set invariants over input.
   <li> <tt>env</tt> = Generate opaque expressions from entropy. Requires --InitEntropy.
   <li> <tt>*</tt> = Same as list,array,input,env
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeEncodeByteArray</tt></td>
<td><tt>bool</tt></td>
<td> Encode the bytecode array. It is decoded before the interpreter is entered. Doesn't work for direct dispatch. Requires opaque expressions. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeObfuscateDecodeByteArray</tt></td>
<td><tt>bool</tt></td>
<td> Obfuscates the program array decoded with opaque expressions. --VirtualizeOpaqueStructs=input,env are the preferable opaque kinds, since it means that the bytecode array depends on input. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicBytecode</tt></td>
<td><tt>BOOL</tt></td>
<td> Similar to the JitDynamic transform, make the virtualized bytecode self-modifying. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicEncoding</tt></td>
<td><tt>hard, soft</tt></td>
<td> How the jitted instructions are encoded. Default=hard.
<ul>
   <li> <tt>hard</tt> = The jitted instructions are encoded as code.
   <li> <tt>soft</tt> = The jitted instructions are encoded as data (not implemented).
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicOptimize</tt></td>
<td><tt>BOOLSPEC</tt></td>
<td> Clean up the generated code by removing jumps-to-jumps. Default=true.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicTrace</tt></td>
<td><tt>INTSPEC</tt></td>
<td> Insert runtime tracing of instructions. Set to 1 to turn it on. Default=0.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicTraceExec</tt></td>
<td><tt>BOOLSPEC</tt></td>
<td> Annotate each instruction, showing from where it was generated, and the results of execution. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicDumpTree</tt></td>
<td><tt>BOOLSPEC</tt></td>
<td> Print the tree representation of the function, prior to generating the jitting code. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicAnnotateTree</tt></td>
<td><tt>BOOLSPEC</tt></td>
<td> Annotate the generated code with the corresponding intermediate tree code instructions. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicCodecs</tt></td>
<td><tt>none, ident, ident_loop, xor_transfer, xor_byte_loop, xor_word_loop, xor_qword_loop, xor_call, xor_call_trace, xtea, xtea_trace, stolen_byte, stolen_short, stolen_word</tt></td>
<td> How blocks should be encoded/decoded. Default=*.
<ul>
   <li> <tt>none</tt> = No encoding
   <li> <tt>ident</tt> = The identity encoding using a single copy JIT instruction
   <li> <tt>ident_loop</tt> = The identity encoding using a copy loop of primitive JIT instructions
   <li> <tt>xor_transfer</tt> = An xor encoding using a single xor JIT instruction
   <li> <tt>xor_byte_loop</tt> = An xor encoding using a copy loop of byte-size primitive JIT instructions
   <li> <tt>xor_word_loop</tt> = An xor encoding using a copy loop of word-size primitive JIT instructions
   <li> <tt>xor_qword_loop</tt> = An xor encoding using a copy loop of qword-size primitive JIT instructions
   <li> <tt>xor_call</tt> = An xor encoding calling a xor function
   <li> <tt>xor_call_trace</tt> = An xor encoding calling a xor function with tracing turned on (for debugging)
   <li> <tt>xtea</tt> = An xtea encryption
   <li> <tt>xtea_trace</tt> = An xtea encryption with tracing turned on (for debugging)
   <li> <tt>stolen_byte</tt> = A byte-sized stolen bytes encoding
   <li> <tt>stolen_short</tt> = A short-sized stolen bytes encoding
   <li> <tt>stolen_word</tt> = A word-sized stolen bytes encoding
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicKeyTypes</tt></td>
<td><tt>data, code</tt></td>
<td> Where the encoding/decoding key is stored (for xor and xtea encodings) Default=data.
<ul>
   <li> <tt>data</tt> = In the data segment
   <li> <tt>code</tt> = In the code segment (not implemented)
</ul>
</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicBlockFraction</tt></td>
<td><tt>FRACSPEC</tt></td>
<td> Fraction of the basic blocks in a function to encode Default=all.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicRandomizeBlocks</tt></td>
<td><tt>BOOLSPEC</tt></td>
<td> Randomize the order of basic blocks Default=true.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicReEncode</tt></td>
<td><tt>BOOLSPEC</tt></td>
<td> If true, blocks will be re-encoded after being executed. If false, blocks will be decoded once, and stay in cleartext. ('False' is not implemented; this option is always set to 'true'.) Default=true.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicDumpCFG</tt></td>
<td><tt>BOOLSPEC</tt></td>
<td> Print the jitter's Control Flow Graph. This requires graphviz to be installed (the dot command is used). A number of pdf files get generated that shows the CFG at various stages of processing: CFGAfterInsertingAnnotations.pdf, CFGAfterSimplifyingJumps.pdf, CFGAfterTranslatingAnnotations.pdf, CFGBeforeInsertingAnnotations.pdf, CFGDumpingFunctionFinal.pdf, CFGDumpingFunctionInitial.pdf, CFGFixupIndirecJumps.pdf, CFGReplaceWithCompiledBlock.pdf, CFGSplitOutBranches.pdf, CFGSplitOutDataReferences.pdf, OriginalCFG.pdf Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicTraceBlock</tt></td>
<td><tt>BOOLSPEC</tt></td>
<td> Print out a message before each block is executed. Default=false.</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicTraceBlock</tt></td>
<td><tt>STRING</tt></td>
<td> Print out a message before each block is executed. (Not currently implemented.) Default="".</td>
</tr>
<tr>
<td><tt>--VirtualizeDynamicCompileCommand</tt></td>
<td><tt>STRING</tt></td>
<td> A string of the form "gcc -std=c99 -o %o %i", where "%i" will be replaced with the name of the input file and "%o" with the name of the output file. For example, if your program uses the math library, you should set --VirtualizeDynamicCompileCommand="gcc -std=c99 -o %o %i -lm". Default="gcc -std=c99 -o %o %i".</td>
</tr>
</table>

